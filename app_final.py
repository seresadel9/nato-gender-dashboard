# -*- coding: utf-8 -*-
"""NATO Gender Integration Insights Dashboard (Streamlit)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aW13Sahog07IuYutg3ZsPSznhn6pZVfP
"""

# -*- coding: utf-8 -*-
"""
NATO Gender Integration Insights Dashboard
"""
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score
from scipy.spatial import ConvexHull
import matplotlib.pyplot as plt
import warnings

# --- Suppress Warnings for a Cleaner Dashboard ---
warnings.filterwarnings('ignore')

# --- NATO Color Palette & Custom Colors ---
NATO_BLUE_DARK = "#0047AB"
STEEL_BLUE = "steelblue" # For positive coefficients
LIGHT_BLUE = "lightblue" # For negative coefficients
NATO_GREY = "#696969"

# --- Configuration ---
RANDOM_STATE = 42

# ==============================================================================
# HARD-CODED THESIS RESULTS & CLUSTER PROFILES
# ==============================================================================
@st.cache_data
def get_static_results():
    results = {}
    # --- Inference Model Results ---
    rec_data = {'Variable': ['Flexible Hours Available', 'Female labor force participation (World Bank) %', 'Gender wage gap (World Bank)', 'GDP per capita (World Bank)', 'Part-time Employment Available', 'Sexual Harassment Prevention Policy', 'Tertiary education rate (women)', 'Urbanization % (World Bank)', '% women in OF-6+', 'Conscription_both', 'Conscription_male'], 'Coefficient': [6.0558, 2.1782, -1.2541, -0.9493, -0.0978, 6.2634, 0.6866, -0.9460, 0.0787, 1.4813, 2.1399], 'P-value': [0.0000, 0.0000, 0.0001, 0.0370, 0.8766, 0.0000, 0.0506, 0.0414, 0.7879, 0.3130, 0.0055]}
    results['recruitment'] = pd.DataFrame(rec_data).set_index('Variable')
    ret_contemp_data = {'Variable': ['Female labor force participation (World Bank) %', 'Flexible Hours Available', 'GDP per capita (World Bank)', 'Gender wage gap (World Bank)', 'Has Gender Advisor', 'Has general retention policies', 'Has specific retention policies targeting women', 'Parental Leave Weeks', 'Part-time Employment Available', 'Sexual Harassment Prevention Policy', 'Uses NATO Gender Training Package', 'Conscription_both', 'Conscription_male'], 'Coefficient': [1.6829, 2.4237, -0.7282, -1.8518, 0.6247, 3.3063, -2.6614, -0.7351, 0.4327, 3.9850, 1.7388, -0.6479, 2.6387], 'P-value': [0.0000, 0.0090, 0.0792, 0.0000, 0.4163, 0.0000, 0.0051, 0.0381, 0.5446, 0.0000, 0.0203, 0.6956, 0.0022]}
    results['retention_contemp'] = pd.DataFrame(ret_contemp_data).set_index('Variable')
    ret_lagged_data = {'Variable': ['Female labor force participation (World Bank) %', 'Flexible Hours Available_lag1', 'GDP per capita (World Bank)', 'Gender wage gap (World Bank)', 'Has Gender Advisor_lag1', 'Has general retention policies_lag1', 'Has specific retention policies targeting women_lag1', 'Parental Leave Weeks_lag1', 'Part-time Employment Available_lag1', 'Sexual Harassment Prevention Policy_lag1', 'Uses NATO Gender Training Package_lag1', 'Conscription_both', 'Conscription_male'], 'Coefficient': [1.5756, 2.5512, -0.7850, -1.9032, 0.7972, 3.4635, -2.7978, -0.6964, -0.1041, 4.1882, 1.5399, -0.7774, 2.8887], 'P-value': [0.0003, 0.0112, 0.0873, 0.0000, 0.3581, 0.0001, 0.0075, 0.0753, 0.8945, 0.0000, 0.0645, 0.6774, 0.0030]}
    results['retention_lagged'] = pd.DataFrame(ret_lagged_data).set_index('Variable')

    # --- Cluster Profile Results ---
    results['countries_in_cluster'] = {
        0: ['Albania', 'Canada', 'France', 'Greece', 'Hungary', 'Latvia', 'Slovenia', 'United States'],
        1: ['Italy', 'Luxembourg', 'Montenegro', 'North Macedonia', 'Poland', 'Romania', 'Turkey'],
        2: ['Belgium', 'Bulgaria', 'Croatia', 'Czech Republic', 'Denmark', 'Estonia', 'Finland', 'Germany', 'Iceland', 'Lithuania', 'Netherlands', 'Norway', 'Portugal', 'Slovakia', 'Spain', 'Sweden', 'United Kingdom']
    }
    dv_means_data = {'% of women in the military': {0: 16.00625, 1: 6.106349, 2: 11.335283}, 'Retention_Success_Score': {0: 7.806944, 1: 17.60381, 2: 13.170215}, '% women who left': {0: 14.393056, 1: 4.59619, 2: 9.029785}}
    results['cluster_dv_means'] = pd.DataFrame(dv_means_data)
    iv_means_data = {'Parental Leave Weeks': {0: 49.944444, 1: 44.587302, 2: 60.415138}, 'Maternity Leave Weeks': {0: 27.597222, 1: 29.619048, 2: 36.296732}, 'Sexual Harassment Prevention Policy': {0: 0.777778, 1: 0.825397, 2: 0.830065}, 'Has general retention policies': {0: 0.777778, 1: 0.634921, 2: 0.640523}, 'Has specific retention policies targeting women': {0: 0.236111, 1: 0.190476, 2: 0.326797}, 'Has Gender Advisor': {0: 0.444444, 1: 0.650794, 2: 0.673203}, 'Uses NATO Gender Training Package': {0: 0.541667, 1: 0.444444, 2: 0.48366}, 'Flexible Hours Available': {0: 0.777778, 1: 0.666667, 2: 0.836601}, 'Part-time Employment Available': {0: 0.444444, 1: 0.492063, 2: 0.745098}, 'GDP per capita (World Bank)': {0: 28730.926747, 1: 28984.75771, 2: 39113.047512}, 'Female labor force participation (World Bank) %': {0: 46.426166, 1: 42.386408, 2: 46.957002}, 'Tertiary education rate (women)': {0: 91.416484, 1: 71.528972, 2: 87.561151}, 'Gender wage gap (World Bank)': {0: 6.98764, 1: 8.114497, 2: 7.057305}, 'Urbanization % (World Bank)': {0: 72.125, 1: 67.920635, 2: 78.156863}, '% women in OF-6+': {0: 0.786111, 1: 0.01619, 2: 0.401542}, 'Conscription_both': {0: 0.0, 1: 0.0, 2: 0.091503}, 'Conscription_male': {0: 0.125, 1: 0.142857, 2: 0.235294}, 'Conscription_none': {0: 0.875, 1: 0.857143, 2: 0.673203}}
    results['cluster_iv_means'] = pd.DataFrame(iv_means_data)
    return results

static_results = get_static_results()

# --- Data Loading & Prediction Model Training ---
@st.cache_data
def load_and_train_for_prediction(file_path='cleaner_NATO_Gender_Model_Populated_NCGP_Data.xlsx'):
    try:
        # Re-using the same verified cleaning logic
        sheets = pd.read_excel(file_path, sheet_name=None)
        column_mapping = { 'Urbanization % (world Bank)': 'Urbanization % (World Bank)', 'Tertiary education rate (women) (UNESCO)': 'Tertiary education rate (women)', 'Tertiary education rate (women) (OECD)': 'Tertiary education rate (women)', 'Part-time Employment Available (Yes/No)': 'Part-time Employment Available', 'Part-time Employment Available (1/0)': 'Part-time Employment Available', 'Flexible Hours Available (Yes/No)': 'Flexible Hours Available', 'Flexible Hours Available (1/0)': 'Flexible Hours Available', 'Has gender recruitment policy (binary)': 'Has gender recruitment policy', 'Has general retention policies (binary)': 'Has general retention policies', 'Has specific retention policies targeting women (binary)': 'Has specific retention policies targeting women', 'Has Gender Advisor (1/0)': 'Has Gender Advisor', 'Uses NATO Gender Training Package (1/0)': 'Uses NATO Gender Training Package', 'Sexual Harassment Prevention Policy (1/0)': 'Sexual Harassment Prevention Policy', 'Sexual Abuse Prevention Policy (Yes/No)': 'Sexual Abuse Prevention Policy', 'Conscription type (none / male / both)': 'Conscription type' }
        yearly_dfs = [df.rename(columns=column_mapping).assign(Year=int(sheet_name)) for sheet_name, df in sheets.items() if sheet_name.lower() != 'sources' and str(sheet_name).isdigit()]
        master_df = pd.concat(yearly_dfs, ignore_index=True)
        master_df.columns = master_df.columns.str.strip()
        dup_names = master_df.columns[master_df.columns.duplicated(keep=False)].unique()
        for name in dup_names:
            idxs = np.where(master_df.columns == name)[0]; merged = master_df.iloc[:, idxs].bfill(axis=1).iloc[:, 0]
            master_df = master_df.drop(master_df.columns[idxs], axis=1); master_df.insert(idxs[0], name, merged)
        skip_cols = ['Country', 'Year', 'Conscription type'];
        for col in master_df.columns:
            if col not in skip_cols and master_df[col].dtype == 'object': master_df[col] = pd.to_numeric(master_df[col], errors='coerce')
        binary_cols = ['Part-time Employment Available', 'Flexible Hours Available', 'Has gender recruitment policy', 'Has general retention policies', 'Has specific retention policies targeting women', 'Has Gender Advisor', 'Uses NATO Gender Training Package', 'Sexual Harassment Prevention Policy', 'Sexual Abuse Prevention Policy']
        for col in binary_cols:
            if col in master_df.columns: master_df[col] = pd.to_numeric(master_df[col], errors='coerce').astype('Int64')
        master_df['Year'] = master_df['Year'].astype(int); master_df['Country'] = master_df['Country'].astype(str)
        to_drop = ['Paternity Leave Weeks', 'Mean Childbearing Age', 'Currently married (20-24) %', 'Has gender recruitment policy']
        master_df = master_df.drop(columns=[c for c in to_drop if c in master_df.columns], errors='ignore')
        all_continuous_cols = ['GDP per capita (World Bank)', 'Female labor force participation (World Bank) %', 'Tertiary education rate (women)', 'Gender wage gap (World Bank)', 'Urbanization % (World Bank)', 'Parental Leave Weeks', 'Maternity Leave Weeks', '% of women in the military', '% women who left', '% women in OF-6+']
        all_continuous_cols_present = [col for col in all_continuous_cols if col in master_df.columns]
        master_df[all_continuous_cols_present] = master_df.groupby('Country')[all_continuous_cols_present].transform(lambda g: g.interpolate(method='linear').ffill().bfill())
        for col in all_continuous_cols_present:
            if master_df[col].isnull().any(): master_df[col].fillna(master_df[col].mean(), inplace=True)
        bin_cols = ['Part-time Employment Available', 'Flexible Hours Available', 'Has Gender Advisor', 'Uses NATO Gender Training Package', 'Has general retention policies', 'Has specific retention policies targeting women', 'Sexual Harassment Prevention Policy']
        bin_cols_present = [col for col in bin_cols if col in master_df.columns]
        master_df[bin_cols_present] = master_df.groupby('Country')[bin_cols_present].transform(lambda g: g.ffill().bfill()).fillna(0).astype('Int64')
        if 'Conscription type' in master_df.columns:
            master_df['Conscription type'].fillna('none', inplace=True)
            cons_dummies = pd.get_dummies(master_df['Conscription type'], prefix='Conscription', dtype=int)
            master_df = master_df.drop(columns=['Conscription type'])
            master_df = pd.concat([master_df, cons_dummies], axis=1)
        unscaled_df = master_df.copy()
        if '% women who left' in unscaled_df.columns:
            unscaled_df['Retention_Success_Score'] = unscaled_df['% women who left'].max() - unscaled_df['% women who left']

        # Train Prediction Models
        pred_models = {}
        rec_features = list(static_results['recruitment'].index)
        rec_target = '% of women in the military'
        rec_df = unscaled_df[rec_features + [rec_target]].dropna()
        X_rec = rec_df[rec_features]; y_rec = rec_df[rec_target]
        rec_model = LinearRegression().fit(X_rec, y_rec) # Fit on all data for best prediction
        pred_models['recruitment'] = {'model': rec_model}

        ret_features = list(static_results['retention_contemp'].index)
        ret_target = '% women who left'
        ret_df = unscaled_df[ret_features + [ret_target]].dropna()
        X_ret = ret_df[ret_features]; y_ret = ret_df[ret_target]
        ret_model = LinearRegression().fit(X_ret, y_ret) # Fit on all data for best prediction
        pred_models['retention'] = {'model': ret_model}

        return unscaled_df, pred_models

    except Exception as e:
        st.error(f"Failed to load or process data: {e}"); return None, None

unscaled_df, prediction_models = load_and_train_for_prediction()

# ============================ STREAMLIT APP LAYOUT ============================
st.set_page_config(page_title="NATO Gender Integration Insights", page_icon="🛡️", layout="wide")
st.markdown(f"""<style> .main .block-container {{ padding: 2rem; }} h1, h2, h3 {{ color: {NATO_BLUE_DARK}; }} </style>""", unsafe_allow_html=True)
st.title("🛡️ NATO Gender Integration Insights Dashboard")
st.markdown("#### Predicting Female Recruitment and Retention in NATO Militaries: A Regression and Clustering Analysis of Demographic, Socioeconomic, and Policy Factors")


st.sidebar.title("Navigation")
page = st.sidebar.radio("Select a page:", ["Dashboard Overview", "Recruitment Analysis", "Retention Analysis", "Country Clusters", "Country-Specific Forecast Tool"])
st.sidebar.info("Dashboard by Seres Adél Zsófia, presenting the finalized findings of her bachelor's thesis.")

def plot_coef_chart_from_df(df, title, positive_color, negative_color):
    coef_df = df.copy(); coef_df['Significant'] = coef_df['P-value'] < 0.05; coef_df = coef_df.sort_values(by='Coefficient')
    fig = go.Figure(go.Bar(x=coef_df['Coefficient'], y=coef_df.index, orientation='h', marker_color=np.where(coef_df['Coefficient'] > 0, positive_color, negative_color), text=np.where(coef_df['Significant'], '*', ''), textposition='outside'))
    fig.update_layout(title_text=title, xaxis_title="Impact Size (Coefficient)", yaxis_title=None, showlegend=False, xaxis_zeroline=True, xaxis_zerolinecolor=NATO_GREY)
    st.plotly_chart(fig, use_container_width=True)
    st.markdown("<small>*An asterisk (*) denotes statistical significance at p < 0.05.*</small>", unsafe_allow_html=True); st.markdown("---")

# ============================ PAGES ============================
if page == "Dashboard Overview":
    st.header("Overall State of Gender Integration")
    if unscaled_df is not None:
        col1, col2 = st.columns(2); col1.metric("Number of Countries Analyzed", f"{unscaled_df['Country'].nunique()}"); col2.metric("Time Period Covered", f"{unscaled_df['Year'].min()} - {unscaled_df['Year'].max()}")
        st.subheader("Time Series of Key Indicators")
        selected_countries = st.multiselect("Select countries to compare:", options=sorted(unscaled_df['Country'].unique()), default=["United States", "Germany", "Norway", "Turkey"])
        metric_to_plot = st.selectbox("Select metric to display:", options=['% of women in the military', '% women who left'], format_func=lambda x: "Female Representation (%)" if x == '% of women in the military' else "Female Attrition Rate (%)")
        if selected_countries:
            fig = px.line(unscaled_df[unscaled_df['Country'].isin(selected_countries)], x="Year", y=metric_to_plot, color="Country", title=f"Trend of '{metric_to_plot}' in Selected Countries")
            st.plotly_chart(fig, use_container_width=True)

elif page == "Recruitment Analysis":
    st.header("Recruitment Model: Determinants of Female Military Participation")
    plot_coef_chart_from_df(static_results['recruitment'], "Recruitment Model (Fixed Effects)", STEEL_BLUE, LIGHT_BLUE)

elif page == "Retention Analysis":
    st.header("Retention Model: Determinants of Women Leaving the Military")
    st.subheader("Instant Effects Model")
    plot_coef_chart_from_df(static_results['retention_contemp'], "Retention Model (Contemporaneous Effects)", STEEL_BLUE, LIGHT_BLUE)
    st.subheader("Lagged Effects Model (1-Year Lag on Policies)")
    plot_coef_chart_from_df(static_results['retention_lagged'], "Retention Model (Lagged Policy Effects)", STEEL_BLUE, LIGHT_BLUE)

elif page == "Country Clusters":
    st.header("Country Clusters: Identifying Typologies for Gender Integration")
    if unscaled_df is not None and 'Retention_Success_Score' in unscaled_df.columns:
        st.subheader("Cluster Visualization")
        country_df_dvs = unscaled_df.groupby('Country')[['% of women in the military', 'Retention_Success_Score']].mean().dropna()
        pca = PCA(n_components=2, random_state=RANDOM_STATE)
        scaled_data_for_pca = StandardScaler().fit_transform(country_df_dvs)
        kmeans = KMeans(n_clusters=3, random_state=RANDOM_STATE, n_init=10).fit(scaled_data_for_pca)
        country_df_dvs['Cluster'] = kmeans.labels_; pts = pca.fit_transform(scaled_data_for_pca)
        fig, ax = plt.subplots(figsize=(12, 9)); colors = plt.cm.Blues(np.linspace(0.4, 0.9, 3))
        for cluster_id in sorted(country_df_dvs['Cluster'].unique()):
            cluster_points = pts[country_df_dvs['Cluster'] == cluster_id]
            if len(cluster_points) >= 3:
                hull = ConvexHull(cluster_points)
                ax.fill(cluster_points[hull.vertices, 0], cluster_points[hull.vertices, 1], facecolor=colors[cluster_id], edgecolor='black', alpha=0.4, linewidth=1)
        ax.scatter(pts[:, 0], pts[:, 1], c=[colors[label] for label in country_df_dvs['Cluster']], s=60, edgecolors='black')
        for i, name in enumerate(country_df_dvs.index):
            ax.annotate(name, (pts[i, 0], pts[i, 1]), textcoords="offset points", xytext=(5,5), ha='left')
        ax.set_title('Country Clusters Based on Recruitment & Retention Performance', fontsize=16)
        ax.set_xlabel(f"PC 1 ({pca.explained_variance_ratio_[0]:.1%})"); ax.set_ylabel(f"PC 2 ({pca.explained_variance_ratio_[1]:.1%})"); ax.grid(True, linestyle='--', linewidth=0.5)
        st.pyplot(fig)

        st.subheader("Cluster Profiles")
        tab1, tab2, tab3 = st.tabs(["Country Lists", "Performance Metrics (DVs)", "Characteristics (IVs)"])
        with tab1:
            for i in range(3):
                st.markdown(f"**Cluster {i}:** {', '.join(static_results['countries_in_cluster'][i])}")
        with tab2:
            st.dataframe(static_results['cluster_dv_means'].style.background_gradient(cmap='Blues'))
        with tab3:
            st.dataframe(static_results['cluster_iv_means'].T.style.background_gradient(cmap='Blues', axis=1))

elif page == "Country-Specific Forecast Tool":
    st.header("Country-Specific Policy Forecast Tool")
    if unscaled_df is None or prediction_models is None: st.error("Data could not be loaded. The forecast tool is unavailable.")
    else:
        countries_list = sorted(unscaled_df['Country'].unique()); selected_country = st.selectbox("1. Select a Country to Analyze", countries_list)
        if selected_country:
            latest_data_row = unscaled_df[unscaled_df['Country'] == selected_country].sort_values('Year', ascending=False).iloc[0:1].copy()
            country_historical_mean = unscaled_df[unscaled_df['Country'] == selected_country].mean(numeric_only=True)
            st.subheader(f"2. Current State & Policy Scenario for {selected_country} (Baseline: {latest_data_row['Year'].iloc[0]})")
            with st.form("scenario_form"):
                scenario_data = latest_data_row.copy(); st.markdown("**Adjust policies or socioeconomic factors to forecast their impact.**")
                c1, c2, c3 = st.columns(3)
                with c1:
                    st.markdown("**Policy Levers**")
                    policy_levers = ['Flexible Hours Available', 'Part-time Employment Available', 'Sexual Harassment Prevention Policy', 'Has general retention policies', 'Has specific retention policies targeting women', 'Has Gender Advisor', 'Uses NATO Gender Training Package']
                    for policy in policy_levers:
                        if policy in scenario_data.columns:
                            current_val = bool(latest_data_row[policy].iloc[0])
                            scenario_data[policy] = 1 if st.checkbox(policy, value=current_val, key=f"check_{policy}") else 0
                with c2:
                    st.markdown("**Socioeconomic Factors**")
                    socio_sliders = ['Female labor force participation (World Bank) %', 'Tertiary education rate (women)', 'GDP per capita (World Bank)', 'Urbanization % (World Bank)', '% women in OF-6+']
                    for col in socio_sliders:
                         if col in scenario_data.columns:
                            val = latest_data_row[col].iloc[0]
                            scenario_data[col] = st.slider(col.replace('(World Bank) %', '(%)').replace('(women)','(%)'), min_value=float(unscaled_df[col].min()), max_value=float(unscaled_df[col].max()), value=float(val), key=f"slide_{col}")
                with c3:
                    st.markdown("**Leave & Wage Gap**")
                    other_sliders = ['Parental Leave Weeks', 'Maternity Leave Weeks', 'Gender wage gap (World Bank)']
                    for col in other_sliders:
                        if col in scenario_data.columns:
                            val = latest_data_row[col].iloc[0]
                            scenario_data[col] = st.slider(col, min_value=float(unscaled_df[col].min()), max_value=float(unscaled_df[col].max()), value=float(val), key=f"slide_{col}")
                submitted = st.form_submit_button("▶️ Forecast Impact")
            if submitted:
                st.subheader("3. Forecasted Outcomes")
                rec_model = prediction_models['recruitment']['model']; ret_model = prediction_models['retention']['model']
                baseline_df = latest_data_row.copy()
                for col in rec_model.feature_names_in_:
                    if col not in baseline_df.columns: baseline_df[col] = country_historical_mean.get(col, 0)
                    if col not in scenario_data.columns: scenario_data[col] = country_historical_mean.get(col, 0)
                for col in ret_model.feature_names_in_:
                    if col not in baseline_df.columns: baseline_df[col] = country_historical_mean.get(col, 0)
                    if col not in scenario_data.columns: scenario_data[col] = country_historical_mean.get(col, 0)
                baseline_rec = rec_model.predict(baseline_df[rec_model.feature_names_in_])[0]
                scenario_rec = rec_model.predict(scenario_data[rec_model.feature_names_in_])[0]
                baseline_ret = ret_model.predict(baseline_df[ret_model.feature_names_in_])[0]
                scenario_ret = ret_model.predict(scenario_data[ret_model.feature_names_in_])[0]
                res_col1, res_col2 = st.columns(2)
                with res_col1:
                    st.metric(f"Baseline Recruitment ({latest_data_row['Year'].iloc[0]})", f"{baseline_rec:.2f}%"); st.metric("New Scenario Recruitment", f"{scenario_rec:.2f}%", delta=f"{scenario_rec - baseline_rec:.2f}% points")
                with res_col2:
                    st.metric(f"Baseline Attrition ({latest_data_row['Year'].iloc[0]})", f"{baseline_ret:.2f}%"); st.metric("New Scenario Attrition", f"{scenario_ret:.2f}%", delta=f"{scenario_ret - baseline_ret:.2f}% points", delta_color="inverse")